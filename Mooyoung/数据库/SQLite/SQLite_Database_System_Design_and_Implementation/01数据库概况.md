# 第一章  数据库概况

- 学习目标

  读完本章后，你将学到：

  - 一个数据库系统，它是什么，为什么它很重要
  - 一些与数据库相关的重要概念以及术语
  - SQL语言以及在数据库系统中如何执行SQL语句
  - 事务以及它们在SQL语句执行中的作用
  - 计算机平台（操作系统）在数据库系统上扮演什么角色

- 本章简介

  本章对数据库理论进行了比较笼统的介绍，对本书的核心主题（即数据库管理）有着直观而全面的理解。本章解释了数据库和数据库管理系统的目的，并讨论了它们对数据库用户的实际作用。本章介绍了关系数据库及其管理领域的几个关键概念和术语。本章涉及到一个假想的数据库管理系统的几乎所有主要子系统。本章非常简短的介绍了这些概念。您可以查阅有关数据库理论的教科书，以了解更多有关这些概念和其他相关概念的介绍。

  数据库管理系统要么作为用户级独立应用程序运行，要么作为直接链接到独立应用程序的用户级（共享）库运行。在这两种情况下，数据库系统都依赖于本地底层操作系统提供的各种服务。因此，在讨论数据库系统之前，本章首先向您介绍操作系统。此处假设您熟悉操作系统的概念。在这里，本文回顾了那些对于设计和开发数据库系统至关重要的操作系统概念，让您重新熟悉一下。本章描述了一个典型计算机平台的全景图，它由硬件资源、操作系统和其他实用程序组成，并使您直观地理解典型操作系统的工作原理。如果你熟悉操作系统的概念，你可以跳过或略过下面的部分。这部分是[12]的回顾。

## 计算机导论

计算机是强大的由电源装置提供能量的数据操纵引擎。此外，它由许多独立的物理设备组成，我们称之为硬件资源。
计算机中的硬件资源至少包括处理器、一组主存和一些输入输出（简称I/O）设备。键盘、鼠标、显示器、磁盘、打印机和网卡等都是I/O设备。

每个硬件资源都做一些特定的工作，比如存储、传输或操作信息。硬件资源相互交换信息，以完成各自的工作，并使计算机作为一个整体有效、平稳地运行。它们通过相互连接的导线进行通信。最重要的硬件资源是处理器。它是数据操作引擎，总体控制其他所有资源的活动。第二个重要的资源是主存，它存储处理器和I/O设备需要的信息。处理器使用I/O设备与外部环境进行交互，并存储信息以备将来检索。例如，显示器以可读的形式显示信息，磁盘存储在电源断开后仍能保存的信息，网卡用于与其他计算机交换信息等等。

处理器一旦被激活，经过很短的初始化时间后，就会一个接一个地执行机器指令，直到电源断开。处理器循环地从主存储器中提取、解码和执行指令。每一条指令执行时都标识了处理器执行下一条指令的内存位置。简而言之，处理器是一条接着一条地执行指令，指令执行的流程由指令执行的结果本身决定。然而，在某些情况下，计算机中的某些事件可能会突然改变正常的执行流程。这些事件称为中断。当中断发生时，处理器完成正在执行的指令，中断当前的指令执行流程，并通过执行其他内存位置的指令开始新的执行流程。在这种情况下，我们说处理器正在处理中断。在中断处理终止时，处理器恢复原来被中断的指令执行流程。

用户使用计算机来解决他们的各种（计算）问题。他们在计算机上开发和运行应用程序来完成工作。现代的硬件资源大多提供复杂的“难以使用”的复杂接口，应用程序开发人员操纵它们将是一项耗时且令人生畏的任务。为了减轻他们的困难，我们需要复杂的有着特殊用途的程序来调动硬件资源。这种有特殊用途的程序可以由具有丰富的硬件知识和相关经验的开发人员编写。这些特殊的程序将使应用程序开发人员免受复杂的硬件资源的影响，并简化应用程序对硬件资源的使用。这些特殊的操作个别硬件的程序被放在一起，形成一个控制计算机中所有硬件资源的软件整体，这个整体构成了一个更大的软件——操作系统的一部分。

从本质上讲，操作系统是一种控制所有硬件资源的软件，它有效地为用户提供了一种比基础硬件资源更方便使用的新软件机器。它提供了一个执行环境，用户可以相对轻松地开发和运行他们的应用程序。操作系统的两个主要目标是：（1）用户使用计算机的便利性；（2）硬件资源的有效利用。每种操作系统都在两者之间取得了平衡。

操作系统位于用户应用程序和硬件资源之间，并提供应用程序可以在运行时使用的许多服务。它依赖底层硬件资源来实现服务。它定义了一组服务访问点，应用程序连接到适当的访问点以从操作系统获得所需的服务。到服务访问点的连接调用称为系统调用。系统调用类似于操作系统空间中的普通函数调用。它们是操作系统的编程接口。为了使应用程序开发更加容易，并使应用程序可以跨不同的操作系统移植，IEEE POSIX 标准定义了一组应用程序编程接口（简称API）。应用程序一般不直接进行系统调用。相反，它们像普通函数调用一样调用这些API。这些API反过来进行系统调用，为应用程序获取适当的操作系统服务。这些API以共享库的形式存在。例如，在Linux系统中，libc共享库包含了读、写、sleep等的实现，以及基于C语言的应用程序的API函数。这些库在运行时嵌入到应用程序中。

所谓计算机系统，是指装有操作系统的计算机。也就是说，它由裸硬件资源和接口操作系统软件组成。作为一个整体，它为计算机用户开发和运行其应用程序提供了一套服务。操作系统发行版通常附带一组实用程序。实用程序是现成的专用独立应用程序，不同于操作系统程序，它帮助用户尽可能方便地操作计算机。编译器、汇编器、加载器、链接器、调试器、数据库管理软件（这是本书的重点）、shell以及常见的I/O操作等等，都是实用程序。

在下面的两个小节中，我将简要讨论一些数据库管理系统开发人员可能需要熟悉的硬件和操作系统的概念和特性。我将非常简短地讨论这些概念。有兴趣的读者可以查阅任何操作系统教科书，以了解更多有关这些概念和其他相关概念的介绍。

###  硬件平台

普通的应用程序开发人员通常编写符合POSIX标准的应用程序，并运行在本机操作系统之上。他们可能知道一点操作系统，但他们不需要了解太多的硬件平台。但是，一些应用程序（特别是系统程序或实用程序）开发人员可能需要了解一些硬件设备。数据库管理系统是一种利用持久性存储设备的实用程序。数据库系统设计人员和开发人员最好有一些硬件资源的基本知识，特别是关于外部存储设备（如磁盘（持久存储数据））的工作原理。我之前简要地讲过处理器和主存的功能。在本小节中，我首先讨论将I/O设备连接到主机计算机系统的I/O控制器，然后讨论磁盘及其访问开销。

#### I/O控制器

I/O设备通过I/O控制器与上位机系统相连。一些设备自带I/O控制器。它们代表主处理器在I/O设备上执行I/O操作。现代的I/O控制器大多是自主设备，它们可以在不受主处理器干预的情况下独立执行I/O操作，即使它们的工作分配是由主处理器控制的。

每个I/O控制器循环接受主处理器的命令和输入的数据，然后执行命令，并将输出数据和状态信息返回给处理器。处理器通过向控制器发送I/O命令和输入数据来指导I/O控制器做什么。控制器收到处理器的命令后，开始以自己的方式和速度执行命令，可能需要一段时间才能完成命令的执行。当命令执行确实结束时，控制器将命令执行的状态和命令的输出发送给处理器。

几乎所有的现代I/O控制器都配备了中断电路。当控制器想要引起处理器的注意时，它通过在与处理器中断引脚相连的（控制器的）输出中断请求线上发出信号来触发处理器的中断。在接收到中断时，处理器暂停正在进行的程序执行，并开始（在操作系统中）执行一个新的程序来处理中断。在中断服务处理程序中，处理器从控制器收集状态信息和输出数据。通常I/O控制器会一直等待，直到主处理器处理中断。一旦中断被清除，它就可以开始新的工作。

#### 磁盘

磁盘作为在线持久存储设备被广泛使用。逻辑上，磁盘是由固定大小的块组成的数组。一个块是一个字节序列，通常存储1024、2048或4096字节的数据。块是主机系统和磁盘系统之间的数据传输单位。磁盘是一个直接寻址的设备，可以以合理的速度以任意顺序访问数据块。

为了了解磁盘的工作原理，我们需要了解它们的物理结构。圆盘由许多扁平的圆形金属板组成，称为盘片。盘片由高度抛光的玻璃或陶瓷材料制成，表面涂有一层精细的氧化铁磁性材料，可以以磁编码的形式存储和保留信息。所有盘片堆叠在一个单一的主轴。当磁盘运行时，盘片以高但恒定的速度旋转。对于每个盘面，都有一个读写头，负责读写盘面上的数据。所有的读写头都连接在一个手臂上，它们都在一条垂直的直线上对齐。手臂水平地来回移动，以在盘片表面上定位磁头，因此，所有读写磁头一致地一起移动。

在使用磁盘存储信息之前，我们需要组织盘片表面的空间。每个盘面被分割成若干同心圆轨道。磁道是盘片表面上的薄圆形条纹区域。轨道是围绕圆盘主轴的同心环。位于一个磁盘臂位置上的所有磁道统称为圆柱体。一个圆柱包含一个轨道和一个盘面。每条轨道又分为若干扇区，一个轨道可包含数百个扇区。扇区是固定大小的空间。扇区大小是硬盘的一个特性，该值在硬盘制造时设置，不可更改。扇区是可以从磁盘写入或读取数据的最小单位。

如前所述，磁盘空间在逻辑上被看作是磁盘块的阵列。操作系统以块为单位在磁盘上存储信息。每个块是位于同一轨道上的连续扇区序列。格式化磁盘时，块大小可以设置为扇区大小的倍数。不同的块占用不同的扇区。每个块由一个元组编址，元组由柱面号、磁道号和起始扇区号组成。

#### 磁盘访问开销

主处理器不能直接访问磁盘块中的各个字节，除非该块被复制到主存中。即使处理器需要从一个块中读取几个字节，整个块也会被读入主存。类似地，它将整个块写入磁盘。处理器将块的元组地址提供给磁盘的I/O控制器，从而使整个块（它的所有扇区）在主存中可用。在磁盘访问中涉及到三个时间组件。首先，需要一段时间来将圆盘臂定位到正确的气缸上，这称为寻道时间。其次，读写头在请求块的第一个扇区的开头需要一段时间，这称为旋转延迟时间。第三，在磁盘和主存之间传输数据所需的时间，称为传输时间。为了提高性能，通常会进行扇区交错和扇区倾斜。

#### 磁盘操作

我们假设磁盘控制器支持至少两种操作，即读和写。读操作接受一个块地址并返回该块的内容，而不改变原始内容。写操作需要一个块地址和一个值，并用新值覆盖块内容;它是一个就地更新，先前的值被销毁。有些磁盘驱动器在其内置内存中缓存块。在这种磁盘中，写入的值可能不会立即到达磁盘表面。对于这样的磁盘，我们需要一个额外的操作来将驱动器的缓存刷新/同步到磁盘表面。如果没有同步操作，将数据库存储在那里可能会有风险。

**非原子写**：磁盘表面的写绝不是原子的，原子的意思是指操作不可分割。在用新的内容覆盖块的原始内容的过程中，写操作可能会失败（如断电导致写失败），从而部分地修改块。这样的块内容被认为是损坏的，因此使用是有风险的。不幸的是，即使是本地操作系统的奇偶校验逻辑也有可能检测不到一个损坏的块。数据库系统设计人员必须注意到这一事实，并在数据库管理软件中采取一些预防措施尽可能避免或规避数据毁坏数据库。

### 操作系统

操作系统，连同底层的硬件平台，本质上提供了一个软件平台（即，一台软件机器），它看起来是独立于硬件平台的。它管理所有硬件资源的使用，优化它们的性能，并解决它们的访问冲突。为了便于开发和维护，操作系统软件被划分为许多子系统。每个子系统可以管理特定的硬件资源，和（或）向子系统用户提供一些服务。值得探寻的子系统是进程系统、虚拟内存和文件系统。我们也有由系统调用、中断和异常处理例程组成的外部接口。（异常是由处理器本身产生的内部中断。）我假设您熟悉操作系统的概念。您可以参考任何操作系统教科书，如[12]，以了解更多关于操作系统的工作原理。在下面的两个子部分中，我将回顾数据库系统设计人员和开发人员可能需要知道的两个概念，即进程和文件系统。

#### 进程和线程

用户通过运行数据库管理系统等应用程序（和实用程序）来完成任务。处理器执行这些程序。操作系统通过过程的抽象来跟踪程序执行的活动。进程表示一个程序执行的实体。该实体跟踪程序执行的状态。在概念层面上，过程这个术语通常用来表示一个实体，它好像在执行某个任务（由程序解决），并且在执行任务时向操作系统请求资源，并将获得的资源释放回操作系统。我使用过程这个术语来实际标识程序执行。进程通常由一个称为进程标识符（pid）的数字来标识，不同的进程有不同的进程标识符。你可以使用pid来查询进程。（在Linux系统中，你可以查看/proc/pid目录来了解进程的更多信息。）

操作系统通过创建一个新进程来启动一个应用程序的（新的）执行。保证新进程的pid与系统中其他进程的pid不同。进程被分配一些主内存来保存程序和数据。随着程序执行的进行，操作系统将向进程分配各种资源，并在程序执行完成或进程不需要这些资源时回收这些资源。

每个进程都与一个地址空间相关联，称为逻辑地址空间，进程从这里执行指令和访问数据。一个进程的逻辑地址空间包含来自不同来源的程序和数据。地址空间包括一个应用程序的可执行映像和各种库的可执行映像。它们共同构成代码，也就是应用程序逻辑。这些源还提供程序数据，通常称为静态数据。此外，当进程执行程序时，它会有不同的数据，称为动态数据。一个地址空间通常被划分为许多大小可变的块。在Linux系统中，进程地址空间由四个块组成：代码、数据、堆栈和堆。后两者是动态数据。地址空间由操作系统的内存管理组件映射到主内存中。

在传统的操作系统中，两个程序的执行（即使它们涉及到执行同一个程序）由两个不同的进程表示。一个进程获取的资源不能被另一个进程使用。在一些现代操作系统中，地址空间可以被许多执行链共享。也就是说，它们（操作系统）允许在单个地址空间内并发，并且许多进程同时共享相同的地址空间。因此，一个进程可以从它的地址空间执行多个指令序列。执行序列的每个链通常被称为一个线程，它与同一进程中的其他同级线程并发执行同一个程序。这个过程被称为多线程进程。每个线程都有一个不同的标识符，称为线程标识符，与进程标识符不同。线程是工作分配的单位，而进程是多线程系统中资源分配的单位。也就是说，线程自己执行相同的应用程序，但它们通过所在进程获取资源，并且它们可以共享资源，而不管哪个特定的同级线程获得了这些资源。

#### 文件系统

用户在计算机系统中创建和存储信息，以便以后检索和操作。系统将信息存储在持久的外部存储设备中，比如可以在断电时保留信息的磁盘。用户可以在抽象的文件中看到他们存储的信息。操作系统实现了一个软件层，即文件管理系统（简称FMS），在存储系统的用户视图和物理存储设备之间架起桥梁。FMS通过对存储设备的物理属性进行设备无关的文件抽象，帮助用户操作存储在物理设备中的信息。例如，磁盘和闪存设备的工作方式不同，但是文件系统用户通常不希望知道它们之间的区别。它们通过相同的API集以相同的方式访问两个设备上的文件。

不严格地说，文件以字节序列的形式存储相关信息的集合。应用程序可以从文件中读写字节；它们可以指定一定的字节数为起始点进行读或写。FMS帮助应用程序存储字节，以及从文件中检索字节。用户通常不关心文件内容在存储设备中如何存储以及存储在何处。它们通过文件名和文件中的相对位置来标识特定的信息。文件名和相对位置被FMS转换为设备中适当的物理位置。就文件内容而言，FMS是一个被动实体。它在内容中看不到任何结构。它将内容视为一个字节字符串。用户应用程序可以看到内容中的结构。应用程序将该文件视为不同类型记录的集合。例如，数据库将结构化信息存储在文件中，只有数据库管理系统才能理解其结构。

底层设备空间的管理由FMS负责。正如我在第5页的1.1.2节中所讨论的，FMS将磁盘视为一个固定大小块的数组。它跟踪哪些块正在使用，哪些块是空闲的。最初，所有的块都是空闲的。当需要时，它会为各种用途分配空闲块。当创建或扩展一个文件时，由于附加了新数据到文件，新的块分配给该文件。当文件被删除或截断时，文件中的块将被释放到设备。由于FMS需要维护存储设备上的各种数据结构，空间分配和再分配都是昂贵的操作。您可能会注意到，与访问主存相比，访问磁盘是一个非常缓慢的操作。

针对不同的存储设备开发了大量的文件管理系统。在这里，我将简要讨论Linux中基于磁盘的Ext2系统。文件由存储在磁盘上的inode对象中的文件控制信息表示。Ext2系统将每个文件划分为固定大小的逻辑块，逻辑块存储在任何物理数据块（d块）中—d块中包含一个逻辑块，反之亦然。一个inode对象存储大约12个指向d块的直接指针，d块存储前12个逻辑块。其他d块通过各种索引块（i块）访问。inode中的一个条目使用单个间接索引，一个条目使用双间接索引和另一个条目使用三重间接索引。对于非常大的文件，我们需要更多的间接i块。inode还保存其他信息，如文件所有者、访问权限、大小、各种时间戳等。d块和i块通常分散在磁盘上。

在使用文件之前，进程需要告诉操作系统为它打开文件。Linux系统在成功打开后，返回一个文件描述符给进程，这是一个小的整数值。在以后的文件操作中，进程使用描述符作为句柄，直到它关闭文件。最初，文件（inode和内容本身）在磁盘中。当进程读写文件时，FMS读写磁盘块。FMS在内存中维护磁盘块的缓存，以加速对这些块的访问。

在进程操作文件时，有一些事情可能变得不可预测。读操作的执行不会改变文件的内容，而写操作会改变文件的内容。（I）对一个文件的写会立刻到达内存中的缓存（FMS），但可能不会立即到达磁盘表面。数据块和索引块通常由FMS异步写入磁盘。这些块可能不会按照应用程序所期望的顺序写入磁盘。（2）文件内容本身可能与文件inode不一致。例如，文件的实际大小还没有在inode文件中更新；或者更新了大小，但数据块还没有链接到文件。（3）在最坏的情况下，在数据传输到磁盘表面的过程中，可能会由于断电而导致部分块损坏。数据库系统设计人员和开发人员必须意识到这些复杂性，他们必须有一个计划来处理数据库管理软件中的这些方面。Linux系统实现fsync系统调用，强制inode和文件内容在磁盘表面正确；但是，不幸的是，这个操作不是原子的，也就是说，不是不可分割的。

还有一个问题。许多进程可以并发地打开同一个文件并处理该文件。同一文件上的并发冲突操作（例如写操作）可能会产生一些额外的问题。Ext2文件系统为所有进程提供了文件的单一视图：对文件的写入立即对所有打开该文件的进程可见。并发写可以任意交错；Ext2不能保证读写的原子性。如果读写之间需要更好的同步，则进程需要自己显式地进行同步。Linux系统支持用于同步目的的文件锁定原语。进程可以对整个文件或文件的某个区域设置读/写锁，以禁止其他进程对文件（区域）应用冲突的操作。

## 数据库系统概论

本节介绍一些基本的数据库概念、含义和术语，特别是关系数据库管理领域的概念。关于关系数据库的更多内容见第28页的1.3节。

### 数据项

数据项是携带或保存一段信息的东西，而该信息表示某些物理或逻辑实体的状态。信息以数据项值的形式编码。也就是说，我们赋予该值的意义就是信息。然而，我们经常交替使用这三个术语，即数据、值和信息来表示相同的意思。一个数据项可以是一个整数，一个人的名字，一个房子的地址，一个blob，一个表，或者类似的任何东西。数据项的大小称为其粒度。例如，整数数据项可以是1、2、4、8等字节数。粒度指定数据项可以携带多少信息。在本书中，我们经常抽象地引用数据项（或简单地说，数据），而不明确它们的含义或粒度。

本质上，每个数据项都驻留在某个空间中，并且有一个名称或地址，我们可以通过这个名称或地址引用该数据项。可以在数据项中存储什么值取决于数据项的类型。该类型还定义了可以应用于该类型数据项以操作其值的各种操作。至少，我们应该能够读取当前值并使用新值覆盖它。

### 数据库

数据库是包含许多单个（持久）数据项的单一存储库。然而，它不仅仅是一个存储库。数据项通常不独立存在于数据库中。数据项之间是相互关联的。因此，数据库包含相关数据项的集合。数据项上的关系共同满足一些完整性约束，这些约束是数据项值上的断言条件。数据库状态由数据库中所有数据项在任意时刻的值决定。如果处于该状态的所有数据项的值满足数据库上定义的所有完整性约束，则该数据库状态是一致的。

建立数据库的原因是为了帮助人们跟踪各种重要的信息。数据库通常存储关于某些现实世界系统的信息，一致的数据库状态表示特定的现实世界场景。例如，大学数据库可以存储关于所有学生、课程、院系、员工等的信息。用户对数据库应用各种操作（称为数据库操作），以从数据库中检索或删除信息，并存储新信息或修改数据库中的现有信息。

在计算机系统中，数据库通常驻留在一个或多个普通本机文件中，这些文件通常称为数据库文件。当对数据库应用操作时，这些文件的内容将被操作以反映新的数据库状态。也就是说，数据库（也就是高级别的）操作被数据库管理系统转换成文件（也就是低级别的）操作。

### 数据库应用程序

用户在数据库中创建、存储、检索、维护和操作数据。它们可以将数据存储在诸如磁盘之类的持久存储设备上（抽象为一个或多个文件），还可以通过使用shell脚本、文件编辑器等各种系统实用工具，以一种特殊的方式手动管理数据。这种方法在过去被称为文件处理系统。但是，这种方法很快就变得很麻烦，而且，特别是对于不熟悉数据库的用户来说，更是一种操作数据库的危险方式。另一种方法是针对数据库开发和运行专门设计的应用程序，称为数据库应用程序。这些应用程序可以由数据库专家开发，普通用户也可以相对轻松地使用这些应用程序，而不必担心数据项如何存储在数据库中。现代数据库是通过执行数据库应用程序来访问的。任何人都可以相对轻松地执行这些应用程序。应用程序仅通过对数据库应用定义良好的操作来操作数据库。用户独立地运行这些应用程序，而且通常是并发运行的。它们对数据库应用查询和更新，分别读取和操作存储在数据库中的数据。

### 数据模型

如果数据库中的数据项是随机存储的，它们之间没有相关性，那么对数据的操作可能成为一项复杂、乏味、错误删除的任务。应用程序可能会针对非结构化/无组织的数据进行调优，应用程序开发也会变得繁琐。为了便于管理，在将数据项存储到数据库中之前，要先以某种标准形式对其进行结构化。此外，相关的数据项被聚集在一起，这样就可以很容易地找到它们，并且可以有效地迭代。当由不同开发人员编写的许多独立应用程序访问同一个数据库时，数据的结构和组织就更加可取了。所有应用程序都应该看到相同（或类似）结构的相同数据。

我们需要一个工具来表示所有数据项及其关系。在数据处理中，我们需要做的第一件事是创建用户数据的模型。模型创建了数据“用户视图”的表示。它确定哪些数据项将存储在数据库中，定义它们的结构，并建立它们之间的关系。数据建模方案由一组概念（帮助描述数据项）和一组规则（帮助将数据项组合到不同的类中）组成。给定类中的所有数据项都有一组公共属性，这些属性共同定义了类的模式。模式是一个模板，它指定类中可以包含何种类型的数据，它是类中数据项结构的大致描述。

在过去的几十年里，人们发明了不同的数据模型。不同的数据库系统使用不同的数据模型来描述、构造和组织数据项。层次结构、网络、关系和对象数据模型已经成功地用于这些目的。使用最广泛的模型是关系数据模型。在本书中，我只讨论关系数据模型。

#### 关系数据模型

在关系数据模型中，最基本的概念是实体和关系。实体是某种抽象的对象，描述的是与其他实体不同的现实世界（物理或逻辑）的事物，而关系则是两个或多个实体之间的关联。实体是用户希望在数据库中存储的信息。关系建立不同实体之间的连接。关系信息和实体信息一样有价值。例如，在大学数据库中，一个特定的学生或一门特定的课程是一个实体，注册会在这两个实体之间建立一个关系。在关系数据模型中，一个数据项可以是实体数据、关系数据或它们的集合。我将在下一小节中讨论它。

#### 实体关系模型

如上所述，数据库中的数据项不是孤立存在的。数据库是数据项的内聚集合。实体-关系（简称ER）模型是表示数据项之间的内聚性的一种方法，也是从概念上组织数据的实践中最常用的模型。ER模型在数据库设计的概念上以图形化的方式定义实体和关系之间的连接。这些图称为ER图。（然而，该模型没有定义任何数据项上的操作。）该模型使用三个主要元素：实体集、属性和关系集。

在ER模型中，实体的特征是一组属性。在属性集中，每个属性都有一个不同的名称。属性描述用户感兴趣的实体特征或属性。具有相同属性的相似实体的集合形成实体集或实体类。在ER模型中，实体集由具有所有相关属性的抽象名称表示。名称是一个模板，用于描述实体集中可以包含什么类型的实体。例如，在大学系统中，模板名称“Students”定义了大学中所有学生的公共属性，而另一个模板“Departments”定义了所有部门的公共特征。大学数据库中的所有学生都在同一个实体班级中。图1.1描述了student实体类的典型模板：所有的属性都显示为椭圆形，类是矩形的。图中的草图是ER图。该图还描述了Departments实体类。

此处略过图1.1。

根据定义，集合中的元素是不同的。通常只有少数几个属性值可以用来测试区别性。对于任何给定的实体集，其值将一个实体与另一个实体区分开来的属性统称为实体集的键。在图1.1中，键用粗体属性表示。对于学生ER图，SID（立柱标识符）是键，而对于系，DID是键。

关系是两个或多个实体之间的关联。（这些实体不必来自同一个实体类。）一个相似关系的集合形成一个关系集或关系类。也就是说，关系类描述了来自某些实体类的元素之间的一种特定的关联。在ER模型中，一个关系类用菱形框表示（见图1.2）。一个n元关系类有n个相关联的实体类，并且可能有自己的属性。如图所示，Admitted-to是一个二元关系类（在Students和Departments实体类之间），它具有doj属性，表示学生加入院系的日期（date of joining）。您可能注意到同一个实体类可以参与许多不同的关系类。

此处略过图1.2。

### 关系型数据库

在前一小节中，我介绍了ER模型来表示数据世界的“用户视图”。我需要将模型的元素（即实体集和关系集）转换为数据库对象，即关系。在关系型数据库中，所有的数据库对象都是某种关系。在数学中，关系是有序对的集合。在这里，我们可以理解概念层次上的关系是一个包含行和列的表（也就是二维矩阵）。关系是关系型数据库中基本元素的单位。实体集和关系集都表示为单独的关系。用户将他们在关系数据库中的数据视为有限的关系集合，除此之外别无其他。从本质上说，关系是唯一（更高层次的）用于表示关系型数据库中所有信息的数据结构。

有一些已知的技术可以从ER图派生关系模式的定义。它们还可以通过将关系分解成更小的标准范式关系来帮助您减少或消除数据库中的冗余信息。在本书中，我不讨论这些技巧。任何关于数据库理论的标准教科书都有一个或多个关于这个主题的章节。

让我们更深入地研究一下表的概念。列通常称为属性或字段，行称为元组或记录。属性作为列的名称，每个属性都有一个不同的名称。表中的每一列为表中的所有行标识一个属性。列的数量决定了表的程度或度。每个表都有一个描述表的列属性和其他属性的模式。表中的每个单元格存储一个值。行可以为每个属性保存一个值，该值来自一组预定义的值，称为”attribute domain“。每一行都用所有属性的值来表示一个实体或一个关系。您可能会注意到，一个表可以是空的，也就是说，它没有任何行，但是它必须有一个模式。这是因为如果没有模式，我们就不知道表中可以存储什么样的行。表中的行数称为其基数。

关系中的所有行都具有相同的格式，即相同的类型化值序列。图1.3给出了上述student关系的典型实例。图中的顶部一行标识了关系的属性名称，它不是实际关系的一部分。关系的度是3。SID是唯一标识所有行的关系的关键。您可能注意到，所有行中特定列中的值不必不同。这个关系有四行不同的行，也就是说，这个关系的基数是4。

此处略过图1.3。

关系数据库的一个主要优点是它支持许多简单但功能强大的关系高级操作。在数据库世界中，这些操作通常被称为查询。它们用查询语言表示。与过程语言不同，查询通常是声明性的。他们规定要做什么。您可以用查询语言来表述它们，并且可能不需要担心数据项的“位和字节数”。查询处理系统负责执行查询，以从数据库中获得所需的结果。结构化查询语言（简称SQL）是现代关系数据库中使用最广泛的查询语言。单一语言既用于定义数据库对象（如表），也用于操作对象。关于SQL的更多内容见第32页的1.3.3节。

### 完整性约束

如前所述，数据库状态由数据库在任意时刻拥有的所有数据项的值组成。数据项的值可能是相互关联的，这些关系满足用这些值表示的某些属性。这些属性称为不变量或约束。它们加强存储在各种数据项中的信息之间的关系。在关系数据库中，完整性约束被表示为来自一个或多个关系的行（部分）值的条件。完整性约束通常是基于数据库包含的真实世界数据的语义来制定的。如果一个数据库状态满足所有的完整性约束（即不使任何完整性约束失效），则该数据库状态被认为是有效的或完整的；否则表示状态无效或不一致。在定义或更改关系的模式时指定完整性约束，当关系被修改时，数据库会检查和执行完整性约束。如果关系上的插入、更新和删除操作违反任何完整性约束，则应该拒绝它们。约束可以增强域完整性（列允许的值）、行完整性（定义允许的列值组合来构造行）、引用完整性（将两个关系的行值关联起来）。在下面的子部分中，我将讨论关系数据库中一些广泛使用的完整性约束。

#### 域约束

给定一个关系，它的每个属性都有一个数据类型，该类型定义了属性可以拥有的一组值。这叫做域约束。除了域约束之外，我们还可以指定属性可以拥有的域值的合法范围；这个约束通常称为检查约束。例如，可以先将一个属性声明为整型，然后指定其值大于零。前者是域约束，后者是检查约束。当在关系中插入一行时，系统需要确保这些值是有效的，也就是说，它们不会违反域和检查约束。

#### 非空约束

NULL是一个特殊的SQL值，可以替换为任何属性的实际值。SQL中的NULL值不同于给定数据类型的所有有效值。它表示一个未知的或“不在乎”的值。您可能注意到NULL不同于某些编程语言中使用的零或空格。如果一个列被指定为“NOT NULL”，数据库系统必须禁止在其中存储NULL值。

#### 主键约束

给定一个关系，如果在所有的键列中没有两个不同的行具有相同的值，那么该关系的一组列就被称为键，这对于任何严格的列子集都不成立。（允许对某些关键列使用相同的值，但不允许对所有关键列使用相同的值。）因此，一个键唯一地标识关系中的一行。如果键定义的第二部分不为真，我们称之为超键。如果给定关系有多个键，则它们称为候选键，其中一个键被模式设计器指定为主键。第15页图1.3中的SID列是student关系的关键。没有其他键，因此SID是唯一的候选键，因此是主键。集合{SID, Name}是一个超键。主键中的列不能有NULL值。

#### 唯一键约束

根据定义，主键是唯一的：没有两行可以有相同的主键值。一个关系不能有两个主键。还有一种指定多个唯一性的替代方法。模式设计器可以指定关系的任何一组列是唯一的：关系中的任何两行都不能具有相同的列值。唯一列可以有NULL值；在这种情况下，同一列中的两个NULL值被认为是不同的。

#### 外键约束

一个关系中的一组列可以用来引用另一个关系中的元组。该集合必须对应于第二个关系的主键（或在第二个关系中声明所有列是唯一的）。集合被视为从第一个关系到第二个关系的符号指针。集合中的列统称为相对于第一个关系的外键。如果对于第一个关系中的每一个外键值，第二个关系中的元组在外键列中具有相同的值，则我们说数据库满足这两个关系之间的外键约束。如果数据库中的所有外键约束都被强制执行，我们就说数据库实现了引用完整性。这些约束有效地加强了关系之间的“存在关系”。

### 索引

一组数据项上的索引是一种数据结构，它可以帮助根据数据项的值更快地查找数据项。索引结构存储通过最有效的路由指导数据查找的控制信息。在关系数据库中，我们在关系列上定义索引。索引总是与单个关系相关联，但一个关系可以有零个、一个或多个索引。尽管索引不是关系数据模型的一部分，但它们在数据库中被广泛用于加快对关系（特定值的存在）中的行进行搜索。当查询不需要扫描整个关系时，索引可以在速度上产生巨大的差异。（全关系扫描会从关系中检索所有元组，这对性能有损，并会显著降低查询处理速度。）

索引是在基本关系的一组属性上定义的。这些属性统称为索引搜索键，或简称为索引键。（基关系的）模式属性的任何子集都可以用作索引搜索键，而搜索键不需要是基关系的键。（但实际的数据库系统可能会限制出现在索引键中的属性的数量和类型。）关系上的索引可以根据搜索关键字段的值加快行选择的速度。每个索引结构存储相应的搜索键值和对基关系中元组的引用/指针。如果索引键是关系的主键，那么该索引被称为主索引。否则，它是一个二级索引。大多数数据库系统允许在同一关系上有许多二级索引。

索引由用户创建和删除，但由数据库系统维护。数据库用户不能直接对索引应用读/更新操作。当在基本关系中插入、删除和更新行时，数据库系统自动地在索引中维护所需的搜索信息。索引信息存储在数据库本身，或者作为单独的关系，或者作为其他一些数据结构。您可能会注意到，关系上的许多索引的出现可能会大大减缓关系上插入、更新和删除操作的执行成本。

在关系数据库系统中广泛使用的两种类型的索引是哈希和B-树及其变体。哈希索引是一种快速查找索引。哈希索引通常被实现为存储搜索路由信息的桶的集合（以及指向基关系中的元组的指针）。索引实现了一个哈希函数，该函数用于将任何搜索值映射到一个bucket中，在bucket中对给定值执行实际搜索。哈希索引不适用于搜索两个给定搜索值范围内的行的基本关系。B-树索引是一种有序树。它对搜索键值维护一个预定义的排序顺序。它允许点查找搜索以及从基本关系中选择一系列值（按排序顺序），而不必扫描整个关系。树中的每个节点都包含数据和子指针。数据中的搜索键值用于路由遍历树。B-树的一种变体，称为$B^+$-树，其中只有叶节点包含数据项（或指向基元组的指针），内部节点只包含搜索路由信息和子指针。给定一个搜索值，非叶节点将搜索指向一个适当的叶节点，在那里执行实际的搜索。

### 数据库管理系统

维护数据库中的数据项有两种方法。一种（老方法）是定制应用程序，以便它们“直接”操作数据库中的数据。应用程序直接读取数据库文件，操作刚刚读取的信息，并将新信息写回文件。应用程序将根据数据库中的数据的内部结构和组织进行调优。也就是说，它们变得依赖于文件格式。对应用程序开发人员来说，独自维护大型数据库可能是困难的。确保数据库完整性约束将非常困难，特别是当应用程序或本机操作系统可能在数据库更新过程中失败时。将数据库恢复到可接受的一致状态对应用程序开发人员来说是一个巨大的挑战。当数据库大小增长，并且许多用户同时访问数据库时，这个任务变得更加繁琐。由于并发性，数据项很有可能失去其完整性约束和内聚性，即使应用程序完全正确地运行着。尽管一些应用程序开发人员可能能够编写超级高效的数据操作应用程序，但通常他们对数据库的访问效率很低。此外，应用程序开发时间可能会变得非常长，因为开发人员需要担心数据库中每个数据项的“位和字节”。应用程序变得不必要的大。如果我们决定更改数据的内部结构，可能需要重写所有的应用程序，而这可能并不划算。

另一种替代方法（现代方法）是使用一个独立的、专用的软件系统，应用程序通过该系统访问其数据库。系统定义了许多高级操作（与本地文件系统支持的读、写操作不同），应用程序可以将这些操作用作数据库API。专家数据库系统开发者可以编写高效的数据访问和操作程序来实现这些API。它们可以处理与并发控制和故障恢复相关的问题。数据库应用程序与底层数据管理解耦。它们独立于文件格式和文件管理，并且没有内置的文件处理功能。因此，可以显著减少应用程序开发时间，以及它们的规模和维护成本。

数据库管理系统（简称DBMS）是一种软件，它主要帮助用户尽可能方便地存储、检索和操作数据库中的数据项。DBMS的概念是为了克服我们在文件处理系统中遇到的许多问题而构想和发展的。DBMS提供了一个平台（一种位于本地操作系统顶部的新软件环境），用户可以在其中相对容易地开发和运行他们的数据库应用程序（见图1.4）。用户将数据库视为高级数据项（如关系）的内聚集合，而不是普通本机文件中的位和字节串。它们与数据库应用程序交互，数据库应用程序又与DBMS交互，DBMS又访问数据库文件中的数据项。应用程序不做任何文件处理，也就是说，它们没有嵌入文件处理逻辑。当需求出现时，他们通过DBMS查询数据库，从数据库中读取数据，当他们处理完数据后，他们可以再次通过DBMS将数据写回数据库。

简而言之，应用程序在概念级别上将数据库看作是抽象数据项（如表）的集合，并通过DBMS对数据库应用高级操作（API）来操作数据。应用程序不涉及文件等底层资源的管理。它们只关心概念性数据，并对数据库应用进行更高级的操作来操作数据值。在数据库和应用程序之间转换这些操作和传输数据时，DBMS就像一个黑匣子。它实际上做了所有的文件处理工作来访问数据库文件中的数据项。一个典型的DBMS允许用户以一种有组织的、有效的方式访问数据。DBMS维护数据的结构，它们之间的关系以及各种约束。它还负责应用程序在运行时设想的并发控制、故障恢复和数据保护。在本小节的其余部分，我将简要地讨论DBMS是如何执行它的各种工作的。

此处略过图1.4。

#### 事务

用户可以在概念级别上看到数据项及其关系。DBMS将数据存储在数据库文件中，并维护用户定义的数据项及其关系的逻辑结构。数据库存储关于某些现实世界系统的信息。数据库必须准确地反映真实世界系统的状态。用户通过在数据库上执行应用程序来改变数据库的状态。应用程序读取和修改数据库中的相关数据项，以模拟真实世界系统的演变。在修改数据项时，我们可能需要非常小心。数据项必须相互一致。应用程序的故障和多个应用程序操作的交错不能产生不一致，或意外的数据库状态，或意外的应用程序行为。DBMS不能使正确的应用程序发生故障。

当前未被任何用户访问的数据库被假定为处于一致状态。读操作不会改变数据库状态，但写操作会。当用户对数据库应用写操作时，数据库从一种一致状态转换到另一种一致状态。通常情况下，状态转换会在临时的不一致的状态中进行，尽管只持续很短的一段时间。有两个问题。（1）如果其他应用程序看到了（临时）不一致的数据库状态，它们可能会因为自身没有缺陷而发生故障。如果应用程序失败，或系统崩溃，或电源故障，数据库将不知不觉地保持相同的不一致状态。但是，DBMS不知道这种不一致，除非明确地通知它。为了以一种透明的方式避免临时的不一致性，应用程序的数据库操作序列被组合在一起，共同保持数据库的一致性。也就是说，当一组数据库操作（与其他的组）隔离执行时，这些操作共同保持数据库的一致性。组即称为事务。您可以认为事务是由一组（较低级）数据库操作组成的较高级操作，当它与其他事务隔离执行时，较低级操作会将数据库从一种一致状态转换为另一种一致状态。只要事务是活动的，也就是说，该事务没有完成，DBMS就会怀疑数据库可能不一致，并采取必要的预防措施。事务是DBMS中的逻辑工作单元。数据库必须跨事务保持一致。

**事务：**事务是对数据项的一系列操作。DBMS的职责是使一系列的动作对外部的观察者来说是不可分割的和即时的（也就是说，所有的动作同时发生）。现代数据库编程模型的核心是事务。它是当今数据库管理中最重要的概念。

事务由应用程序发起。事务中可以有哪些数据库操作由应用程序开发人员决定，而不是由DBMS决定。DBMS假定事务是一致性的单位。也就是说，一个事务从一个一致的数据库开始，当它终止时，如果不受其他事务的干扰，它将生成一个新的一致的数据库。但是部分执行的事务可能会产生不一致的数据库。事务通常是真实世界事件的表示。事件要么发生，要么不发生，而没有中间状态。如果事务失败（也就是中止），DBMS必须从数据库中删除事务的影响，并将数据库状态恢复到事务开始时的状态。

每个DBMS都提供一个接口，应用程序可以通过该接口启动事务，并作为事务的一部分执行数据库操作。稍后，应用程序可以提交或者中止事务。提交操作建议DBMS进行所有更改（如果有的话）的事务持久化。中止操作建议DBMS从数据库中删除事务的影响。在这两种情况下，我们都说事务完成了。应用程序将为新工作启动另一个事务。应用程序只能通过事务对数据库应用操作。在下一小节中，我将讨论事务的关键属性。

#### ACID特性

如前所述，部分执行的事务可能会产生不一致或意外的数据库状态。因此，在事务执行过程中，如果应用程序或系统崩溃，DBMS必须在系统重新启动时首先在开始正常的数据库业务之前将数据库恢复到一个可接受的一致状态。但是，该应用程序并不参与恢复操作。只需DBMS必须保证事务具有这种特性和其他类似的特性。

DBMS通常保证的事务特性称为ACID（结合原子性、一致性、隔离性和持久性的缩写形式）属性，ACID可避免产生不一致的和意外的数据库状态和事务行为。当这些属性得到保证时，应用程序开发人员对数据库的操作就变得更容易了。这四个属性将在下面的条目中讨论。

- 原子性：给定一个事务，它的所有操作要么全部发生，要么不发生。当事务完成时，不存在中间情况。事务的所有操作在数据库中必须都生效，或者“就好像”事务根本没有执行。也就是说，失败或中止的事务对数据库没有影响。（有些人将此属性称为失败原子性。）

- 一致性：事务执行完成后，总是将一致的数据库状态转换为新的一致的状态，而DBMS不会改变事务或使事务行为出错。在存在多个事务和各种故障时，事务的行为不能变得不可预测。你可能会注意到一致性是应用程序和数据库的属性，而DBMS不会改变它。

- 隔离性：即使许多事务可以同时执行，并且每个事务都可以执行许多数据库操作，最终的结果是，这些事务似乎是按照串行顺序执行的，也就是说，事务是一个接一个地执行，而不会交叉执行它们的操作。换句话说，每一笔交易似乎是相对于其他交易是即时执行的。也可以说，每个交易的所有操作都在瞬间“一起”发生的。

- 持久性：成功（即提交）事务的影响必须成为数据库的一部分。一旦DBMS提交了一个事务，它必须能够在任何后续的系统故障后获得该事务的影响。

确保事务的ACID属性是DBMS的主要目标。此外，它可以强制事务遵守数据库完整性约束。如果它们违反了任何完整性约束，则会被强制中止，即回滚（原子性属性的“无”部分）。除此之外，DBMS不知道数据项的语义，也不能控制任何事务组合以及事务对数据的处理。维护跨事务的数据库一致性是应用程序开发人员的责任。事务中操作执行的顺序是由应用程序逻辑决定的，而DBMS尊重操作的顺序。

本质上讲，应用程序在数据库上创建一个事务，通过该事务对数据库应用操作，最后提交或中止该事务。如果应用程序提交事务，则其所有更改在数据库中生效。如果它中止事务，则更改将从数据库中取消。中止可以由应用程序启动，也可以由DBMS强制启动。然而，提交决策总是由应用程序发起的。

#### 事务管理

您可能会注意到应用程序作为单线程/多线程的进程运行。因此，事务是由本地应用程序进程（或其线程）执行的。虽然在操作系统中进程是工作分配的单元，但在DBMS中事务是工作分配的单元。操作系统通过使用进程标识符、进程描述符和操作系统空间中的许多其他相关资源来跟踪进程的活动。操作系统不能理解由进程执行的事务，并且不能确保它们的ACID属性。DBMS本身需要确保ACID属性。单个进程或线程可以有多个并发活动事务，这些事务可以访问相同或不同的数据库。DBMS需要跟踪所有事务的活动，它通过使用事务标识符、事务描述符和其他事务控制数据结构来跟踪每个事务的操作。操作系统并不知道这一点，事务管理是由DBMS执行的用户空间任务。

一致性之外，应用程序同样不会保证另外三个特性。只有DBMS才能确保这些特性。保证这些特性是一项相当大的工作，因为没有数据库操作是真正原子的。（即使处理器执行一条指令也不是真正原子的。）事务的原子性是数据库用户看到的一种错觉。DBMS软件设计者在实现ACID特性时设想了两个基本问题。（1）交易的结果何时可以被其他交易访问？（2）事务的部分执行是如何被取消的（即回滚）？就事务管理而言，DBMS负责两件事：（1）并发控制；（2）故障恢复。并发控制协调事务到数据库上的访问。恢复处理的是在出现故障时将数据库恢复到可接受的一致状态。在接下来的两个子部分中，我将简要讨论两种广泛用于实现ACID特性的方案。

#### 并发控制

并发性是指同时或以某种交叉方式执行两个或多个操作。数据库应用程序的并发执行对于提高资源利用率和减少查询响应时间至关重要。但是，对数据库进行冲突访问的应用程序的并发执行可能导致不一致或意外的数据库状态，可能出现应用程序不希望看到的行为。当应用程序被隔离执行时，也就是说，一个接一个地执行，每个应用程序都看到由它的上一个应用程序生成的一致的数据库状态，因此它们的行为都是预期的。当许多应用程序同时执行时，它们可能会以意想不到的方式相互干扰。有些应用程序可能会看到其他应用程序产生的临时不一致的数据库状态。如果应用程序看到的是一致的数据库状态，它可能会出现异常行为，即使它是绝对正确的。DBMS不能让正确的应用程序发生故障。通过控制应用程序并发来确保数据库一致性是DBMS独有的职责。并发控制是协调应用程序对数据库中数据项访问的活动。它是一种预防机制，确保一个应用程序的工作不受其他应用程序的干扰。它不能有过高的开销，这样会导致正常应用程序的执行速度大幅放缓。

DBMS从应用程序到数据库的所有访问（读和写）都是在抽象的事务中进行的。它确保多个并发事务的执行等价于相同事务的串行执行。这就是所谓的序列化理论。DBMS从事务中控制数据库操作的调度，以实现（事务的）序列化执行。DBMS的并发控制子系统负责确保事务隔离性和原子性。大多数DBMS使用某种加锁方案来隔离相互影响的冲突操作。有一个锁管理器（DBMS的一个子系统），它维护数据项上的锁。数据项的读不会改变该项的值，但写会。许多事务可以并发地读取相同的数据项，而不会相互影响。但是，对特定数据项的写操作相互排斥，对数据项的读操作也排斥。下面是最简单的基于锁的并发控制协议。事务在读取（或写入）数据项之前，获取该数据项的读（或写）锁。写锁与其他锁不兼容，但可以同时存在许多读锁。（复杂的事务管理系统，如[26]，采用了许多其他锁类型。）未能获得锁的事务必须等待锁被授予，否则它将中止自己来回滚其更改。事务在提交/中止时释放它的所有锁。这被称为严格的两阶段锁定协议。该协议产生可序列化的事务执行。

**序列化：**假定有一组事务记为H，如果在H中提交的所有事务都发出相同的数据库操作，并收到与在H中仅包含所有提交事务的序列历史记录中相同的响应，那么H是可序列化的。

#### 故障恢复

并发控制确保在系统中不发生故障时（并发）事务的正确行为。这是一个理想的现实场景。实际上，在运行时可能会出现一些问题。例如，事务可以在没有任何提前通知的情况下自动中止其执行。在这种情况下，DBMS必须取消事务所做的所有更改，并将数据库恢复到事务开始时的状态。即使计算机系统或进程（执行事务）在事务执行过程中崩溃，DBMS也必须确保事务原子性。DBMS扮演着更重要的角色。它确保数据库不会被软件、硬件或电源故障损坏。它使用恢复技术在故障后修复数据库。简而言之，在任何给定的时刻，DBMS必须能够在没有提前通知的情况下恢复数据库。恢复的数据库必须有所有已提交事务的更新，并且不能有任何未提交事务的更新。

DBMS的恢复子系统负责确保事务的原子性和持久性。为了达到恢复目的，DBMS维护与数据库内容完全隔离的附加信息。它维护一个“日志“（通常称为日志）来存储这些信息。日志仅仅是一个记录序列，称为日志记录，存储在一个或多个顺序文件中。日志记录了数据库事务执行的所有写操作。有一个日志管理器（DBMS的另一个子系统），它在日志文件中维护日志记录。每个日志记录都有一个头（它是记录的描述符），以及一个包含生成此日志记录的操作的redo-undo信息的有效负载。日志管理器负责描述符，日志客户端负责有效负载。

为了提高效率，通常日志的一部分保存在稳定存储器中，其余部分保存在易失性主存储器中。在系统故障的情况下，这可能会产生一些问题（例如，丢失日志记录）。DBMS通常遵循两条规则来克服这些问题。在对数据库文件进行更改之前，DBMS创建一个稳定（undo）日志记录来反映已更改的内容。该规则称为write ahead log（简称WAL）协议。（2）当事务提交时，DBMS确保事务的所有（redo）日志记录都在稳定的日志存储中。该规则称为flush-log-at-commit协议。

日志记录大多是只写的信息。他们在正常情况下是不会阅读的。只有在事务中止、进程崩溃或系统故障的情况下，才会读取和处理日志记录，以将数据库恢复到适当的、可接受的一致状态。发生崩溃后，当DBMS重新启动数据库时，它首先对数据库执行恢复操作，然后再启动数据库的正常业务。在恢复期间，部分执行事务的影响将被撤消，已提交事务的影响将使用日志中的日志记录重新执行。DBMS一个接一个地读取日志记录，并将它们与数据库进行相应的redo或undo操作。一个重要的要求是恢复操作必须是幂等的：即使在一行中执行了多次恢复，最后也会产生相同的数据库状态。根据日志记录和恢复策略，DBMS可以进行物理（或值）日志记录，或逻辑（或操作级）日志记录，或包含undo或redo信息或同时包含undo和redo信息的生理日志记录。

#### 检查点

当DBMS在数据库故障后重新启动数据库时，它需要做的第一件事就是恢复数据库。唯一可用的恢复信息是在故障中幸存下来的日志内容。DBMS可能需要从日志中读取所有的日志记录，并根据数据库处理这些记录。因此，恢复成为一项耗时的操作，特别是当日志包含大量日志记录时。为了减少重新启动时的恢复时间，DBMS定期对数据库设置检查点。检查点是数据库和恢复子系统之间的一种同步点。检查点建立一个相对较新的数据库状态和日志内容，这些可以作为将来重启时恢复的基础。使用检查点仅仅是为了减少重新启动处理时间。从本质上说，检查点有助于从日志中消除一些旧的日志记录，因此，它有助于在系统故障时加速重新启动。

### 数据库交互

如今，数据库应用程序与DBMS交互来处理数据库。在与DBMS的交互中有两个方面：（1）应用程序如何与DBMS连接并交换信息；（2）它们如何通过DBMS定义和操作数据库中的数据。我将在接下来的两个子部分中讨论这两个方面。

#### 交互模型

DBMS通常在两种模型中发挥作用：嵌入式模型和客户端-服务端模型。在嵌入式模型中，DBMS被实现为一个用户级的共享库，在运行时成为数据库应用程序的一部分。应用程序进程或线程直接执行DBMS程序/代码以从DBMS获得服务。这是一个自助服务系统。应用程序通过一组API与DBMS通信（见图1.5）。这些是在同一个应用程序进程地址空间中的普通函数调用。此外，一些嵌入式DBMS允许应用程序开发人员在应用程序中实现定制的“回调”函数。他们在回调开始执行时向DBMS注册回调。当需要操作应用程序空间中的数据时，DBMS执行这些回调函数。

此处略过图1.5。

在客户端-服务端模型中，应用程序进程充当DBMS的客户端，DBMS作为一个独立的服务端进程运行（见图1.6）。（实际上，服务端和客户端可以在一个计算机网络中的不同计算机系统上运行。）DBMS程序本身是不能被应用程序进程访问的，但是其中嵌入了一个小型DBMS驱动程序。应用程序进程和服务端进程之间通过使用本机操作系统的一些进程间通信原语进行通信，例如TCP/IP套接字或共享内存。客户端向服务端发送操作请求，服务器执行操作并返回输出给客户端。在客户端-服务端模型中没有回调机制。

此处略过图1.6。

**注意：**大多数商业DBMS都是大型的、高并发的事务处理系统，它们被实现为服务器，通常称为数据库服务器。这个操作模型帮助我们将客户端地址空间保持在最小的大小。由于DBMS运行在一个独立的服务端进程中，它不会受到应用程序错误的影响。有一些小型设备，如手机、PDA，它们受到主存储空间有限、电池电量不足等的限制。这些设备通常使用具有最小功能集的嵌入式DBMS。嵌入式系统不需要维护单独的服务端进程。应用程序进程通过执行DBMS库中的API函数自行执行数据库操作。

#### 交互语言

数据库客户机建立与DBMS的连接，以便对数据库进行一些有用的工作。有各种各样的方法使DBMS工作。在不同的系统中，方法是不同的。有两种广泛的选择：（1）程序性或规定性的方法；（2）非程序性或描述性的方法。在面向过程的系统中，用户在底层的每一小步告诉DBMS它在数据库中应该做什么。在面向描述的系统中，用户告诉DBMS在更高的层次上要做什么，DBMS以最好的方式自己执行任务。

大多数现代DBMS实现了一种特定的描述性编程语言（也称为查询语言），这样用户就可以相对容易地表达DBMS对数据库执行的操作。用户向DBMS发送命令（这是用查询语言编写的程序），DBMS反过来对数据库执行命令，并将结果报告给用户。结构化查询语言（Structured Query Language，简称SQL）是现代关系数据库中最常用的数据库语言。它是非过程语言。每个SQL语句都是该语言中的一个单独的程序或子程序，它描述了要计算什么，而不是如何计算。SQL的美妙之处在于，它让应用程序开发人员专注于“做什么”的部分，而让DBMS实现者专注于“如何做”的部分。

与任何其他编程语言一样，SQL有自己的语法来构造SQL程序。它定义了一组标准的SQL特定基本类型（整数、实数、varchar、blob、日期、时间、时间戳等等）。用户也可以定义他们自己的数据类型，称为域，由基本类型和其他域组成。SQL语句分为两类：数据定义语言（简称DDL）和数据操作语言（简称DML）。DDL用于创建表、索引、约束、域、触发器和视图，DML用于查询、插入、删除和更新表中的行。关于SQL的更多内容将在第32页的1.3.3节中讨论。

## 关系型数据库管理系统

关系型数据库管理系统（简称RDBMS）是一种DBMS，它实现了由关系型数据模型指定的数据结构和数据组织（参见第12页的1.2.4节）。RDBMS支持关系型数据库的用户视图，也就是一组（概念性的）关系表，并将它们连同它们的模式存储在一个或多个数据库文件中。

 关系是二维的概念，而文件是一维的概念。实际上，在大多数操作系统中，文件仅仅是一个字节序列，它们（或它们的FMS）并不维护文件内容上的任何结构。因此，我们需要一个从关系到文件空间的映射。也就是说，需要对文件内容进行适当的结构和组织，以承载关系。用户在数据库上应用高级关系操作来存储、删除和操作关系。RDBMS将这些数据库操作转换为较低级别的文件操作。为此，我们需要一种不同的模式（称为物理模式）来表示文件中的数据。（概念的或逻辑的）模式定义关系的结构，物理模式定义文件的结构。数据库用户永远不会看到物理模式，因此数据库应用程序与物理结构和关系组织相隔离。

本质上，关系型数据库是关系的集合，这些实体和关系信息以元组的形式存储。每个关系都有自己的模式，有用来描述关系中存储的元组值的类型。模式信息也以单独的关系存储在数据库中，称为目录或系统表。（目录也可以用其他名称来称呼，如数据目录、数据字典。）目录存储关于其他关系和目录的元信息。例如，目录可能存储有关用户关系的信息：关系的名称、关系的列数。另一个例子是，编目可以存储列名、列的关系名、列数据类型和默认值等等。所有模式（所有关系的模式）共同定义数据库模式。（您可能注意到，模式设计和细化是用户活动，而不是数据库系统活动。）数据库模式描述了数据库的所有属性。它是数据库应用程序开发工作的基础，因为它清楚地确定了哪些类型的数据可以存储在数据库中。

大多数RDBMS允许应用程序读取目录，但不允许它们更新目录。目录由DBMS更新，这是应用程序创建和更新用户关系的一个副作用。例如，创建新关系会导致在描述新关系及其列的目录中插入新的元组。除了具有用户关系和系统目录外，数据库还可能具有有助于加速搜索数据库的索引。索引有助于更快地查找数据库中的特定数据值。在接下来的两个小节中，我将讨论各种关系操作和这些操作的代数。接下来，我将介绍SQL查询语言，并在两个小节中讨论典型RDBMS的组件。

### 关系操作

给定一组关系，我们需要一种机制来操作这些关系。我们至少应该能够检索、存储、删除和修改关系中的元组。对于应用程序开发人员来说，通过在数据库文件上应用受低级操作系统支持的读/写原语来操作关系是一项令人生畏的错误修剪任务。此外，他们还需要了解数据库文件的物理结构（即物理模式）的详细信息。当然，这不是DBMS的目标。为了缓解这些困难，我们定义了一组更高级别的操作，应用程序开发人员可以相对轻松地应用于关系以完成任务。这些操作称为关系操作。当然，DBMS将以最好的方式执行这些操作，即对文件使用较低级别的原语。有两个著名的数学规则用于指定关系操作。

1. 关系代数。它是关系运算的代数。它定义了许多可应用于关系的操作。这些操作的结果就是关系本身。因此，代数是封闭的。您可以将这些关系操作组合起来，例如，在函数上连接这些关系操作来定义关系上的复杂操作。
2. 关系演算。它是一种描述性语言，允许您描述您想要用关系做什么，而不是如何计算最终结果。

关系演算中的符号更为复杂。在这本书中，我仅限于关系代数。

### 关系代数

由于一个关系中的所有元组都是不同的，并且具有相同的格式，我们可以将该关系视为一个数学集合（元组），将每个元组视为列的有序列表，并为该关系定义一些众所周知的集合论运算。原始的关系运算是（1）投影，（2）选择，（3）笛卡尔积或叉积，（4）集差，（5）并集。其他广泛使用的操作有交叉、连接和分割。对于所有这些操作，输出关系的模式依赖于输入关系的模式。这些操作将在下一小节中定义，以刷新您的记忆。

#### 投影

投影是关系上的一元运算，它返回一个输出关系，该输出关系是通过从给定关系中删除不需要的列而获得的，而输出关系中没有元组的重复。输出关系的模式包含给定关系中未删除的列。

#### 选择

选择是关系上的一元操作，它返回一个输出关系，该输出关系是根据选择条件从给定关系中删除不需要的元组而获得的。只有满足选择条件的元组才在输出关系中。输出关系的模式与给定关系的模式相同。

#### 集差

集差是对两个具有相同模式的关系的二元运算，它返回一个输出关系，其中第一个关系中的元组不在第二个关系中。输出关系的模式与给定关系的模式相同。

#### 并集

并集是两个具有相同模式的关系的二元操作，它返回一个输出关系，其中的元组位于第一个或第二个关系中，或同时位于两个关系中。输出关系的模式与给定关系的模式相同。

#### 交集

交集是对两个具有相同模式的关系进行的二元运算，它返回一个包含这两个关系中的元组的输出关系。输出关系的模式与给定关系的模式相同。

#### 叉积

叉积是对两个关系（可能有不同的模式）的二元运算，它返回一个输出关系，每个元组由每个输入关系的元组组合而成。基本上，第一个输入关系的每个元组都与第二个输入关系的每个元组配对，以在输出关系中产生一个元组。输出关系的模式是给定关系的两个模式的组合。如果这两个模式有一些共同的名称，它们将被重命名，以使结果模式中的所有名称均不同。

#### 连接

连接是对两个关系（可能有不同的模式）的二元操作，它返回一个依赖于各种连接标准的输出关系。有各种各样的连接操作是从原始关系操作派生出来的。条件（或θ）连接是由叉积操作组成的选择操作：选择操作应用于由两个给定关系的叉积返回的输出关系。等连接是条件连接的一种特殊情况，其中选择条件只包含某些给定列的相等。自然连接是所有公共列的等连接；在结果关系中，每个公共列只保留一个。

### 结构化查询语言（SQL）

在上一小节中，我讨论了各种关系操作。我们需要编程语言，以便应用程序开发人员能够在数据库上组合和应用关系操作。这些语言称为查询语言。如前所述，结构化查询语言（Structured Query Language，简称SQL）是为关系数据库编写应用程序时使用最广泛的查询语言。它是当今操作关系数据库的首选语言。SQL为面向集合的非过程数据定义、操作和控制操作提供了功能。与C等编程语言不同，SQL是一种声明性语言，用于指定要执行的操作。每个数据库查询都是用SQL语句表示的，其中每个语句都是一个单独的程序或子程序。DBMS找出执行语句的最佳方式。

SQL包含接近关系代数的功能。此外，它还包括在关系中插入、删除和更新元组的功能，以及在数据库中创建、更改和删除关系的功能。尽管如此，SQL并不是一种图灵完备语言。例如，它没有循环功能。它不打算用于一般用途的复杂计算。它旨在帮助用户高效地访问和管理大型数据集。因此，SQL程序通常嵌入到其他图灵完整编程语言中，如C和COBOL。这些被称为与SQL相关的原生语言或宿主语言。复杂的应用程序逻辑是用原生语言编写的，数据库访问仅使用嵌入式SQL语句完成。但是，由于SQL和原生语言之间的数据类型不匹配，这会导致一些问题。SQL是面向集合的，而原生语言是面向记录的。不同的数据库管理系统不同地解决了数据类型不匹配问题；它们采用不同的机制在SQL空间和原生语言空间之间传输数据。

#### SQL功能

如前所述，SQL语句分为两个部分：用于定义模式的数据定义语言（DDL）和用于制定查询的数据操作语言（DML）。DDL用于创建、更改和删除新的数据库对象，如表、索引、视图、触发器、约束、域。DML用于插入、更新和删除关系中的元组，以及从关系中选择元组。SQL select构造完成投影、选择、叉积和连接关系操作。每个SQL select指定一个或多个关系操作以及一个关系列表，这些操作将应用于这些关系以生成输出关系。没有用于操纵索引的DML。当您对相应的基关系应用操作时，DBMS会自动操纵索引。

您可能会注意到，大多数商业RDBMS对关系的定义略有不同。它被视为一个包或多集，可能不是一个纯集。（这种处理方法仅用于提高计算效率和降低DBMS实现复杂性。）因此，一个关系可能有重复的元组。如果SQL用户在SQL语句的输出中看到重复的语句，他们不应该感到惊讶。SQL还支持许多非关系操作：重复消除、聚合、分组、排序、外部联接。让我们在接下来的小节中学习一些简单的SQL示例。

#### SQL示例

这是我在本书中唯一一个介绍一些简单的正式SQL构造的地方，可以让你大开眼界。SQL语句“create table Students （sid integer primary key, name varchar, address varchar） ”意为在数据库中创建一个名为Students的新表。（如果数据库中已有同名表，则语句执行将失败。）该表有三列，即sid，name，和address。sid列的类型为整数，其他两个为可变长度字符串。关键字“primary key”是一个约束，它表示表中sid列的所有值必须是不重复的且不为NULL；其他两列可能不是唯一的。您可以通过执行SQL语句“insert into Students values （1001, 'Sibsankar', 'Sunnyvale, California'）; ”在Students 表中插入新行；此语句在学生表中插入一个新行，sid值等于1001，name值等于“Sibsankar”，address值等于“Sunnyvale，California”。如果再次执行同一语句，将导致sid值的唯一约束冲突。（您可能会注意到SQL不区分大小写，但任何放在引号内的内容都会按原样处理。）

通过执行SQL语句“select \* from Students”，可以从Students表中检索所有行。它是Students表上的无条件选择操作，它返回表中的所有行。您可以通过执行简单的SQL语句（如“select \* from Students where sid = 1001”）来获取有关特定学生的信息。它是Students表上的一个条件选择操作，它返回表中sid列中值为1001的那些行。由于sid是主键，该语句最多返回一行。where子句用于限制查询操作的表的行数；该子句指定了一个选择条件。在前面的两个SQL语句中，“\*”表示给定表中按模式定义顺序的所有列；这是一种速记符号。你也可以拼出所有的列名和它们的顺序，用逗号分隔。您可以有选择地返回一些（可能不是全部）列值。例如，您可以通过执行“select name from Students”来获取学生姓名。它是Students表上的一个投影操作。它可能返回重复的name ，因为name在Students表中不是唯一的列。你可以通过执行“select distinct （name） from Students”来消除重复。您可以通过执行“select name from Students where sid = 1001”来获取特定学生的名字。它是投影和条件选择运算的组合。假设有另一个表Admitted-to，有三列sid、did和doj。通过执行“select name, doj from Students, Admitted-to where Students. sid = Admitted-to. sid”可以获得学生姓名和他们的加入日期。这是一个连接操作。SQL select执行投影、选择、叉积和连接关系操作。通过执行“delete from Students where sid = 1001”，可以从student表中删除一行。通过执行“delete from Students”，可以删除表中的所有行。该语句不会破坏Students表的模式。通过执行“drop table Students”，可以销毁Students表及其模式。

SQL有五个内置函数，即count、sum、avg、max和min。count函数计算给定表中的总行数。（例如，SQL语句“select count（\*） from Students”返回的是Students表中row的总数。）sum函数计算数字列的和，avg计算平均值，max计算最大值，min计算数字列的最小值。max和min函数也适用于带有排序规则的varchar列。内置函数（除了group by语句）不能与列名混合使用。例如“select sid, count（\*） from Students”是一个非法的SQL语句。内置函数不能用作where子句的一部分。然而，这些函数可以与列名一起使用group by语句；“select name, count（\*） from Students group by name”返回一个有两列的输出表，其中每一行有一个不同的名称和Students 表中数字列的的重复计数。（您可能会回想起以前的SQL经验，group by子句会将结果的一行或多行合并成一行输出。这在结果包含聚合函数时特别有用。）在下一小节中，我将讨论RDBMS如何处理SQL查询。

### 典型RDBMS的组件

图1.7显示了一个典型的基于SQL的RDBMS的典型架构。主要由两个子系统组成：（1）SQL转换器或查询预处理器；（2）查询执行引擎及其子系统。前者通常称为前端，后者称为后端。前端将每一条SQL语句转换成一个内部（RDBMS特定的））程序或数据结构，引擎可以执行（操纵）这些程序（数据结构）来执行SQL语句。有些RDBMS生成的是原生代码而不是引擎代码；许多生成的解析树由引擎遍历；一些（如SQLite）生成内部字节码程序，类似于汇编语言程序。无论这种机制是什么，引擎都是一个虚拟机，它解释前端的输出并产生SQL的输出。

此处图1.7略过。

前端有三个子系统：解析器、优化器和代码生成器。解析器将输入SQL语句分割成标记，并形成语句的解析树。这个树被优化器转换成另一个树。代码生成器处理一个解析树，并生成引擎能够理解的代码（数据结构）。后端由许多子系统组成：（1）存储管理；（2）内存缓冲区或缓存管理；（3）并发控制；（4）恢复管理；（5）事务管理；（6）交互器。存储管理子系统管理物理设备上的空间（如文件）。当文件中的数据项在主存中复制时，数据项在内存中的复制被组织在缓冲区中。缓冲区管理子系统将这个缓冲区作为文件数据的内存缓存来管理。并发控制子系统负责协调事务对数据库的并发访问。这个子系统在不违反数据一致性语义的情况下允许尽可能多的并发。恢复管理子系统在系统/进程失败或事务中止的情况下恢复数据库。

让我们在这里研究一个非常简单的用例示例。假设您连接到一个特定的数据库。如果你执行一条SQL语句“select * from Students”, DBMS会一个接一个地返回表Students中的所有行。为了执行给定的select语句，引擎可以执行以下操作。

1. 打开包含Students表的数据库文件；
2. 倒带文件，将其放置在Students表的开头；
3. 虽然不是在表尾，但按照列出的顺序执行以下子步骤：从当前记录中读取所有列值，将值返回给调用者，将文件位置提前到下一个记录；
4. 关闭该文件。

所有这些文件处理操作对应用程序都是透明的。真正的文件处理是在引擎中进行的。

## 总结

虽然本章的主要重点是介绍与数据库系统相关的概念，但它首先介绍与计算机系统相关的概念。计算机系统由许多硬件资源（如处理器、主存储器和I/O设备，I/O设备有磁盘、键盘、显示器、网络接口卡等）、操作系统、许多共享库和实用程序组成。处理器执行软件程序，主存存储程序和数据，I/O设备帮助处理器与外部世界通信，并将信息存储在持久设备（如磁盘）上。操作系统是硬件资源的总体负责人，它创建了一个用户友好的环境，用户可以在其中相对轻松地开发和执行应用程序。每个应用程序执行都由执行应用程序逻辑的（单线程或多线程）进程表示。进程可以从（向）I/O设备读写信息。磁盘是一个永久性的I/O设备，在电源断开时可以保留存储的信息。用户以文件的形式查看存储在磁盘中的信息。文件管理系统（操作系统的一个组件）管理磁盘上的这些文件，它帮助用户相对轻松地访问存储的信息。它对文件执行打开、关闭、读取、写入、同步等操作，应用程序可以调用这些操作来操作存储在文件中的信息。需要注意的一点是，许多文件操作都不是原子的（即，不是不可分割的），这对于一些应用程序（如数据库系统）来说可能会有问题。

本章的其余部分将介绍数据库系统的各种概念，尤其是关系数据库系统。它定义了数据项、数据类型、值和信息等概念。然后定义什么是数据库，并描述数据库如何存储在本机文件中。通过应用作为数据库应用程序构建块的各种数据库操作来访问数据库。新手用户更喜欢执行数据库应用程序来操作数据库中的数据。数据库应始终处于一致状态，以满足某些用户定义的完整性约束。

建立数据库以存储数据项的第一步是创建一个模型来表示数据项。其中成功地运用了各种数据模型，如层次、网络、关系和对象。这本书讨论的是称为实体关系模型的关系数据模型。数据库中的所有数据项都被分类为不同的实体以及这些实体之间的关系。它们分别称为实体集和关系集。每个实体由一组属性描述，其中一个或几个属性构成一个键，其值将一个实体与其他实体区分开来。

从理论上讲，关系数据库是一组关系。这些也被称为表。这些表以行的形式存储实体集和关系集。表可以由用户创建，也可以由数据库系统本身创建。每个表都有描述其列属性和各种约束的模式。关系数据库通常由用特殊查询语言编写的查询访问。SQL（结构化查询语言）是其中最流行的一种，用于数据定义和数据操作。虽然关系理论不支持索引的概念，但大多数数据库设计人员在表上创建索引以加快数据查找。主要使用的索引是散列和B树。当需要快速点查找时使用散列索引；当需要范围搜索（基于某些排序顺序）时使用B树。

访问数据库的两个主要问题是故障恢复和协调多个应用程序进程对同一数据的并发访问。DBMS（数据库管理系统）负责处理这些问题，以使应用程序开发人员能够专注于他们的应用程序处理逻辑。DBMS采用事务的概念，以确保这两个问题不会导致数据库损坏或数据库应用程序故障。每个事务都由一个或多个数据库操作组成，DBMS确保所有这些操作一起不可分割地执行，或者不发生任何操作。DBMS实际上确保了事务的ACID（原子性、一致性、隔离性和持久性）属性。

## 本书布局

本章介绍了许多数据库的概念和术语。这些概念和新概念将在接下来的章节中以SQLite嵌入式数据库系统为背景进行深入的探讨。本书的其余部分组织如下。

第2章概述了SQLite，它是一个基于SQL的关系数据库管理系统。它以自上而下的方式介绍了SQLite的所有组件。这些组件将在后面的章节中以自下而上的方式详细讨论。本章还讨论了一些SQLite API，并介绍了一些非常简单的SQLite应用程序。总的来说，本章是对SQLite的一个简短介绍，为本书的其余部分奠定了基础。

第3章介绍了SQLite中最底层的存储组织方式。它定义了数据库和日志文件的命名约定及其格式。它讨论了如何将数据库文件划分为固定大小的页面，谁使用这些页面，以及页面如何组织。它还提供用于存储应用程序生成的日志记录的日志文件格式。

第4章讨论SQLite如何通过事务管理用户查询和更新。SQLite执行事务中的每个SQL语句，并确保事务具有ACID属性。本章讨论了用于控制事务并发性的文件加锁方案，以及用于从事务中止和系统故障中恢复的页面日志记录方案。

第五章介绍页模块。该模块在普通面向字节的原生文件之上实现了更高级的面向页面的文件。它可以帮助客户相对轻松地从数据库文件中读取和写入页面。它也是SQLite中的事务管理器和日志管理器。它决定何时获取和释放数据库文件的锁，以及何时在日志文件中写入哪些日志记录。

第6章介绍了页模块上层的树模块。树模块将原始数据库页面组织为B-树和$B^+$-树。SQLite将数据库的内容组织成若干棵树。$B^+$-树整体存储数据表，B-树存储数据表上的索引。树将密钥和数据存储在不可解释的字节图像中。本章讨论用于在树中存储、检索和操作数据的各种数据结构。

第7章介绍了虚拟机（VM）模块。VM是一个解释器，它执行用SQLite内部字节码编程语言编写的程序。它在B-树和$B^+$-树的顶部创建表和索引的抽象结构。本章讨论了用于解释这些树中存储的信息的各种数据结构。它给出了五种基本数据类型，并讨论了存储在表树和索引树中的数据记录的格式。（页、树和VM模块共同实现SQLite的后端（引擎）。）

第8章讨论前端模块。前端预处理所有SQL查询，并生成引擎可以执行的字节码程序。本章介绍了前端的四个子系统，即标记器、解析器、优化器和代码生成器。

第9章介绍了sqlite3 用户接口数据结构。它集成了前几章中介绍的所有内部数据结构。它为读者提供了不同数据结构如何相互关联以及它们如何协同工作的全景图。

第10章讨论了SQLite的一些高级特性。值得注意的是子查询、视图、触发器、排序规则、pragma、自动真空、wal日志等等。

第11章为数据库和相关系统的进一步研究提供了一些参考文献。