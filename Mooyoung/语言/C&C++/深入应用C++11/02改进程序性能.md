# 第2章 改进程序性能

## 右值引用

### 基本概念

- 左值：表达式结束后依然存在的持久对象，可对表达式取地址，所有具名变量或对象都是左值

- 右值：表达式结束时就不再存在的临时对象，不可对表达式取地址，不具名

  - 纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、lambda表达式等
  - 将亡值（c++11新增）：将要被移动的对象、T&&函数返回值、std::move返回值等

- 右值引用（c++11新增）：对右值进行引用的类型，记为T&&。右值引用可绑定到右值表达式上，但不能将右值引用直接绑定到一个左值上

  ```c++
  int i = 11;                // i为左值
  int &r = i;                // ok：r引用i（左值引用）
  int &&rr = i;              // error：不能将右值引用绑定到左值上
  int &r2 = i * 21;          // error：r2不能引用右值
  const int &r3 = i * 21;    // ok：常量引用可以绑定右值（常量左值引用可以绑定一切）
  int &&rr2 = i * 21;        // ok：右值引用绑定右值表达式
  ```

### 规则

- T&&未发生类型推导时，一般就表示右值引用；

  ```c++
  void f(String&& param);            // param是右值引用类型
  void f(std::vector<T>&& param);    // 函数调用之前，T已确定，param是右值引用类型
  template<typename T>
  void f(const T&& param);           // 任何给T&&附加的条件都使得param变为右值引用类型
  ```

- auto&&或函数模板参数类型自动推导的T&&是一个未定的引用类型，记为universal reference。如下所示，T&&发生了参数类型自动推导，param是左值或是右值是不定的，由初始化值类型决定；

  ```c++
  template<typename T>
  void f(T&& param);
  
  f(10);         // param是右值，因为param被右值初始化（10为右值）
  int x = 10;
  f(x);          // param是左值，因为param被左值初始化（x为左值）
  ```

- 所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。如当T&&为模板参数时，输入左值，它会变成左值引用，而输入右值时则变为具名的右值引用；

  ```c++
  int& var1 = x;         // var1类型为int&
  auto&& var2 = var1;    // var2为universal reference，且由左值引用初始化，发生引用折叠，var2为int&
  ```

- 编译器会将已命名的右值引用视为左值，而将未命名的右值引用视为右值；

  ```C++
  void PrintVal(int& i);    // A
  void PrintVal(int&& i);   // B
  void Forward(int&& i)
  {
      PrintVal(i);
  }
  
  int i = 0;
  PrintVal(i);    // i为左值，调用A
  PrintVal(1);    // 1为右值，调用B
  Forward(2);     // 2为右值，但在Forward中入参i为已命名的右值引用，编译器视其为左值，调用A
  ```

### 右值引用可避免深拷贝

- 编译器返回值优化问题：默认开启，加入参数-fno-elide-constructors编译即可关闭返回值优化

  ```c++
  // a.cpp
  #include <iostream>
  using namespace std;
  
  class A
  {
  public:
      A():m_ptr(new int(0))
      {
          cout << "construct " << this << endl;
      }
  
      // 拷贝构造函数
      A(const A& a):m_ptr(new int(*a.m_ptr))
      {
          cout << "copy construct " << this << endl;
      }
      
      ~A()
      {
          cout << "destruct " << this << endl;
          delete m_ptr;
      }
  
  private:
      int* m_ptr;
  };
  
  A Get(bool flag)
  {
      A a;
      return a;
  }
  
  int main()
  {
      A a = Get();  // return处和=处均调用拷贝构造函数
                    // A a; a = Get(); 此写法将调用赋值函数（浅拷贝），发生coredump
      return 0;
  }
  ```

  - 关闭参数优化：构造一次，拷贝构造两次

    ```c++
    // 关闭返回值优化编译
    g++ a.cpp -fno-elide-constructors -std=c++11
    // ./a.out
    construct 0x7ffd54a693f0
    copy construct 0x7ffd54a69430
    destruct 0x7ffd54a693f0
    copy construct 0x7ffd54a69420
    destruct 0x7ffd54a69430
    destruct 0x7ffd54a69420
    ```

  - 打开参数优化：仅构造一次（优化掉两次拷贝构造）

    ```c++
    // 打开返回值优化编译
    g++ a.cpp -std=c++11
    // ./a.out
    construct 0x7ffd873ef2b0
    destruct 0x7ffd873ef2b0
    ```

- 改造a.cpp：class A中加入移动构造函数，构造一次，移动构造两次

  ```c++
  // 移动构造函数（将自动删除赋值函数）
  A(A&& a):m_ptr(a.m_ptr)
  {
      a.m_ptr = nullptr;
      cout << "move construct " << this << endl;
  }
  
  // 关闭返回值优化编译
  g++ a.cpp -fno-elide-constructors -std=c++11
  // ./a.out
  construct 0x7ffeec5f1f60
  move construct 0x7ffeec5f1fa0
  destruct 0x7ffeec5f1f60
  move construct 0x7ffeec5f1f90
  destruct 0x7ffeec5f1fa0
  destruct 0x7ffeec5f1f90
  ```

## move语义

## forward和完美转发

## emplace_back减少内存拷贝

## 可取之处

- 在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。

- 提供右值引用的构造函数的同时，提供常量左值引用的拷贝构造函数，以保证移动不成功时还可以使用拷贝构造，使得代码更加安全。

  



