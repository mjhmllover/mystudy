# 第一章 让程序更简洁更现代

## 理论归纳

### auto用法

#### 推导规则

- 当不声明为指针或引用时，auto的推导结果（变量类型）和初始化表达式抛弃引用和cv限定符（const和volatile限定符的统称）后类型一致（无引用和cv限定符，则正常推导）；

- 当声明为指针或引用时，auto的推导结果将保持初始化表达式的cv属性，也不会丢弃引用（正常推导）；

```c++
int x = 0;

auto * a = &x;      // a->int*, auto->int（声明为指针，正常推导）
auto b = &x;        // b->int*, auto->int*（声明为非指针非引用，初始化表达式为指针，正常推导）
auto & c = x;       // c->int&, auto->int（声明为引用，正常推导）
auto d = c;         // d->int, auto->int（声明为非指针非引用，初始化表达式为引用，丢弃引用）

const auto e = x;   // e->const int, auto->int（声明为非指针非引用，初始化表达式为int，正常推导）
auto f = e;         // f->int, auto->int（声明为非指针非引用，初始化表达式带const修饰，丢弃cv限定符）

const auto & g = x; // g->const int&, auto->int（声明为非指针非引用，初始化表达式为int，正常推导）
auto & h = g;       // h->const int&, auto->const int（声明为引用，初始化表达式为const int&，保留cv属性）
```

#### 限制

- 不能用于函数参数；
- 不能用于非静态成员变量；
- 无法定义数组；
- 无法推导出模板参数；

### decltype用法

### 模板改进

### 列表初始化

- 聚合类型的变量才能进行列表初始化
- 聚合类型定义：
  - 类型是一个普通数组（如int[10]、char[]、long\[2][3]），数组元素是否是聚合类型无所谓
  - 类型是一个类（class、struct、union），且（类的数据成员是否为聚合类型无所谓）
    - 无用户自定义的构造函数
    - 无private和protected的非静态数据成员
    - 无基类
    - 无虚函数
    - 不能有{}和=直接初始化的非静态数据成员
- STL容器具有列表初始化的能力（std::initializer）

### 基于范围的for循环

- 以只读方式遍历容器

  ```c++
  std::vector<int> arr;
  for (auto n : arr)
  {
      std::cout << n << std::endl;
  }
  ```

- 遍历时修改容器中的值

  ```c++
  std::vector<int> arr;
  for (auto& n : arr)
  {
      std::cout << ++n << std::endl;
  }
  ```

- 不希望修改，遍历大对象

  ```c++
  std::vector<std::string> arr;
  for (const auto& str : arr)
  {
      std::cout << str << std::endl;
  }
  ```

- for循环中auto推导出的类型是容器的value_type，而非迭代器；如map对应的就是std::pair，需要使用x.first和x.second提取键值

### std::function和bind绑定器

- 绑定任意参数，实现函数的延迟执行

### lambda表达式

- 方便地使用STL算法，就地定义匿名函数

### 元组

## 可取之处

- 在使用迭代器时，可用auto消除冗长的声明；

  ```c++
  std::vector<std::string> vec = {"abc", "123"};
  for (auto it = vec.begin(); it != vec.end(); ++it)
  {
      std::cout << *it << std::endl;
  }
  ```

- 列表初始化可使得简单的struct可以直接初始化；

  ```c++
  typedef struct ST
  {
      int x;
      std::string str;
  }T_ST;
  
  T_ST st{0, {}};
  ```

- 基于范围的for循环，简化代码；

  ```c++
  std::vector<std::string> vec = {"abc", "123"};
  for (const auto& str : vec)
  {
      std::cout << str << std::endl;
  }
  ```

  